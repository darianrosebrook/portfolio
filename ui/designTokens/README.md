## Design Tokens Strategy

This folder contains the source of truth for our design system tokens. We follow the W3C Design Tokens format with a pragmatic twist for modes, component-level tokens, and CI-friendly validation/outputs.

### What lives here

**Modular Structure (Recommended):**

- `core/` — Modular primitive tokens split by category:
  - `color.tokens.json` — Color palettes, modes, data visualization colors
  - `typography.tokens.json` — Font families, weights, scales
  - `spacing.tokens.json` — Spacing scales
  - `motion.tokens.json` — Durations, easing, delays, staggers
  - `shape.tokens.json` — Border radii, borders
  - `elevation.tokens.json` — Shadows, z-index
  - Plus: opacity, dimension, scale, layout, icon, interaction, component modules
  - `_index.tokens.json` — Module registry (not loaded during build)

- `semantic/` — Semantic roles organized by category:
  - `color.tokens.json` — Foreground, background, border, status colors
  - `typography.tokens.json` — Text styles, hierarchies
  - `components/` — Component-specific semantic patterns
  - Plus: spacing, motion, shape, elevation, control, interaction, focus, datavis, overlay modules
  - `_index.tokens.json` — Module registry (not loaded during build)

**Legacy Monolithic Files (Backward Compatible):**

- `core.tokens.json` — Full primitive tokens (maintained for compatibility)
- `semantic.tokens.json` — Full semantic roles (maintained for compatibility)

**Build Artifacts:**

- `designTokens.schema.json` — Generated JSON Schema for validation and IntelliSense
- `designTokens.json` — Composed aggregate of all tokens (built artifact)

### Authoring rules

- Use the W3C structure: token objects have `$type`, `$value`, optional `$description`, and `$extensions`.
- Always reference primitives from `core.*` in semantic/component tokens. Avoid hard-coded values except where noted (e.g., breakpoints).
- Include appropriate units for `dimension` values (e.g., `px`, `rem`, `em`). Keep ratios like `typography.lineHeight.*` as `$type: "number"`.
- Prefer references over duplication: `"$value": "{core.color.palette.neutral.500}"`.
- Avoid circular references. If a token references itself or its parent branch, validation fails.
- Namespacing: always use explicit `core.` or `semantic.` prefixes in references.

### Custom extensions

We support extensions under `$extensions.design`:

- `paths.light` / `paths.dark` — token references that point to the light/dark variants. Example:

```json
{
  "$type": "color",
  "$value": "{color.palette.neutral.600}",
  "$extensions": {
    "design": {
      "paths": {
        "light": "{color.palette.neutral.600}",
        "dark": "{color.palette.neutral.300}"
      }
    }
  }
}
```

- `calc` — allows CSS `calc()` expressions with token substitution in strings, e.g. `"calc({spacing.size.04} + 2px)"`.

The schema validates both patterns so editors provide IntelliSense and inline errors.

### Schema, validation, and IntelliSense

- `$schema` is local for offline reliability: `"$schema": "./designTokens.schema.json"`.
- The schema is generated by `utils/designTokens/generators/generateSchema.mjs` and is intentionally permissive where nesting is required (`additionalProperties: true`, `anyOf` in group pattern properties) but strict on primitives (types and patterns).
- `utils/designTokens/validators/validateTokens.mjs` runs AJV validation and extra lint checks (units, missing types, suspicious numbers, circular refs).

### Build outputs and where they are used

- Composed JSON: `ui/designTokens/designTokens.json` from `utils/designTokens/generators/compose.ts`.
- Global CSS variables: `app/designTokens.scss` from `utils/designTokens/generators/generateGlobalTokens.mjs`.
- Component-scoped SCSS: `ui/components/**/**.tokens.generated.scss` from `utils/designTokens/generators/generateCSSTokens.mjs`.
- TypeScript token paths: `types/designTokens.ts` from `utils/designTokens/generators/generateTypes.mjs` for code-time autocomplete via `TokenPath` and helpers.

### Quick commands

```bash
# Compose, generate CSS, and types (full pipeline)
npm run tokens:build

# Individual steps
npm run tokens:schema     # regenerate JSON Schema
npm run tokens:compose    # compose core + semantic into designTokens.json
npm run tokens:globals    # emit global CSS custom properties
npm run tokens:scss       # emit per-component SCSS token files
npm run tokens:types      # emit TypeScript TokenPath union
npm run tokens:validate   # AJV + custom validation
```

### Authoring examples

- Core primitive:

```json
{
  "$type": "dimension",
  "$value": "16px",
  "$description": "Base spacing unit"
}
```

- Semantic alias with mode paths:

```json
{
  "$type": "color",
  "$value": "{color.palette.neutral.100}",
  "$extensions": {
    "design": {
      "paths": {
        "light": "{color.palette.neutral.100}",
        "dark": "{color.palette.neutral.800}"
      }
    }
  }
}
```

- Component token referencing globals:

```json
{
  "background": { "$type": "color", "$value": "{color.background.brand}" },
  "paddingX": { "$type": "dimension", "$value": "{spacing.size.04}" }
}
```

### Conventions and guardrails

- Dimensions require units; numbers are unitless. Examples: `"0.5"` → number, `"8px"` → dimension.
- `typography.letterSpacing.*` is a dimension (e.g., `"0em"`), `typography.lineHeight.*` is a number.
- Breakpoints use `px` strings.
- If you add a new custom type, update `generateSchema.mjs` and keep names descriptive; avoid `any` anywhere in code.

### Theming and multi-brand

The semantic layer is designed for multi-brand. A brand can override `semantic.*` (or attach brand namespaces) while `core.*` remains stable. Mode-aware behavior should use `design.paths` where possible to avoid duplication.

### Modular vs Monolithic

**Modular Advantages:**

- Easier to navigate and maintain (smaller, focused files)
- Reduced git merge conflicts (parallel edits to different categories)
- Faster IDE performance and intellisense
- Clear separation of concerns by token category
- Better team collaboration (can assign ownership per module)

**Build Behavior:**
The build pipeline automatically detects and loads from the modular structure (`core/` and `semantic/` directories) if present. It falls back to monolithic files (`core.tokens.json`, `semantic.tokens.json`) for backward compatibility. The composed output (`designTokens.json`) is identical regardless of source structure.

**Migration Path:**
Existing projects can migrate gradually:

1. Modular structure is created alongside monolithic files
2. Both structures are maintained during transition
3. Once validated, monolithic files can be removed or kept as reference
4. All builds work with either structure

### Contributing to Tokens

**Adding a New Token to Modular Structure:**

1. Identify the appropriate module file (e.g., `core/color.tokens.json` for a new color primitive)
2. Add your token following the W3C format:
   ```json
   "newToken": {
     "$type": "color",
     "$value": "#FF0000",
     "$description": "Clear description of purpose"
   }
   ```
3. Run `npm run tokens:build` to regenerate composed file and CSS variables
4. Verify in browser that new token is available

**Creating a New Module:**

If a category grows too large or needs separation:

1. Create new `.tokens.json` file in appropriate directory (`core/` or `semantic/`)
2. Follow the schema structure with `$schema` reference
3. Add tokens under appropriate category name
4. Build pipeline automatically discovers and loads it
5. No changes needed to build scripts

### FAQ

- "Why local schema?" — Reliability (offline/CI), speed, and control over our custom extensions.
- "Why not import an icon library?" — We prefer local assets and Figma Dev Mode MCP; no new icon packages.
- "How do I get token path autocomplete in code?" — Import from `@/types/designTokens` and use `TokenPath` or categorized path types.
- "Can I mix modular and monolithic?" — Yes! The build pipeline supports both. Modular is preferred for new work.
- "Do I need to update both structures?" — No, choose one. If using modular, the monolithic files are maintained automatically during transition.
