## Design Tokens Strategy

This folder contains the source of truth for our design system tokens. We follow the W3C Design Tokens format with a pragmatic twist for modes, component-level tokens, and CI-friendly validation/outputs.

### What lives here

- `core.tokens.json` — primitive tokens (palette, spacing, typography, motion, shape, elevation, etc.). No brand or component semantics.
- `semantic.tokens.json` — semantic roles that reference `core.*` (e.g., `color.background.primary`). Safe to theme/brand.
- `designTokens.schema.json` — generated JSON Schema used for validation and IntelliSense.
- `designTokens.json` — composed aggregate of `core` + `semantic` (built artifact).

### Authoring rules

- Use the W3C structure: token objects have `$type`, `$value`, optional `$description`, and `$extensions`.
- Always reference primitives from `core.*` in semantic/component tokens. Avoid hard-coded values except where noted (e.g., breakpoints).
- Include appropriate units for `dimension` values (e.g., `px`, `rem`, `em`). Keep ratios like `typography.lineHeight.*` as `$type: "number"`.
- Prefer references over duplication: `"$value": "{core.color.palette.neutral.500}"`.
- Avoid circular references. If a token references itself or its parent branch, validation fails.
- Namespacing: always use explicit `core.` or `semantic.` prefixes in references.

### Custom extensions

We support extensions under `$extensions.design`:

- `paths.light` / `paths.dark` — token references that point to the light/dark variants. Example:

```json
{
  "$type": "color",
  "$value": "{color.palette.neutral.600}",
  "$extensions": {
    "design": {
      "paths": {
        "light": "{color.palette.neutral.600}",
        "dark": "{color.palette.neutral.300}"
      }
    }
  }
}
```

- `calc` — allows CSS `calc()` expressions with token substitution in strings, e.g. `"calc({spacing.size.04} + 2px)"`.

The schema validates both patterns so editors provide IntelliSense and inline errors.

### Schema, validation, and IntelliSense

- `$schema` is local for offline reliability: `"$schema": "./designTokens.schema.json"`.
- The schema is generated by `utils/designTokens/generateSchema.mjs` and is intentionally permissive where nesting is required (`additionalProperties: true`, `anyOf` in group pattern properties) but strict on primitives (types and patterns).
- `utils/designTokens/validateTokens.mjs` runs AJV validation and extra lint checks (units, missing types, suspicious numbers, circular refs).

### Build outputs and where they are used

- Composed JSON: `ui/designTokens/designTokens.json` from `composeTokens.mjs`.
- Global CSS variables: `app/designTokens.scss` from `generateGlobalTokens.mjs`.
- Component-scoped SCSS: `ui/components/**/**.tokens.generated.scss` from `utils/generateCSSTokens.mjs`.
- TypeScript token paths: `types/designTokens.ts` from `utils/designTokens/generateTypes.mjs` for code-time autocomplete via `TokenPath` and helpers.

### Quick commands

```bash
# Compose, generate CSS, and types (full pipeline)
npm run tokens:build

# Individual steps
npm run tokens:schema     # regenerate JSON Schema
npm run tokens:compose    # compose core + semantic into designTokens.json
npm run tokens:globals    # emit global CSS custom properties
npm run tokens:scss       # emit per-component SCSS token files
npm run tokens:types      # emit TypeScript TokenPath union
npm run tokens:validate   # AJV + custom validation
```

### Authoring examples

- Core primitive:

```json
{
  "$type": "dimension",
  "$value": "16px",
  "$description": "Base spacing unit"
}
```

- Semantic alias with mode paths:

```json
{
  "$type": "color",
  "$value": "{color.palette.neutral.100}",
  "$extensions": {
    "design": {
      "paths": {
        "light": "{color.palette.neutral.100}",
        "dark": "{color.palette.neutral.800}"
      }
    }
  }
}
```

- Component token referencing globals:

```json
{
  "background": { "$type": "color", "$value": "{color.background.brand}" },
  "paddingX": { "$type": "dimension", "$value": "{spacing.size.04}" }
}
```

### Conventions and guardrails

- Dimensions require units; numbers are unitless. Examples: `"0.5"` → number, `"8px"` → dimension.
- `typography.letterSpacing.*` is a dimension (e.g., `"0em"`), `typography.lineHeight.*` is a number.
- Breakpoints use `px` strings.
- If you add a new custom type, update `generateSchema.mjs` and keep names descriptive; avoid `any` anywhere in code.

### Theming and multi-brand

The semantic layer is designed for multi-brand. A brand can override `semantic.*` (or attach brand namespaces) while `core.*` remains stable. Mode-aware behavior should use `design.paths` where possible to avoid duplication.

### FAQ

- "Why local schema?" — Reliability (offline/CI), speed, and control over our custom extensions.
- "Why not import an icon library?" — We prefer local assets and Figma Dev Mode MCP; no new icon packages.
- "How do I get token path autocomplete in code?" — Import from `@/types/designTokens` and use `TokenPath` or categorized path types.
