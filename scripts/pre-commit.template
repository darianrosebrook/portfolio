#!/bin/sh
#
# Pre-commit hook to detect and prevent committing secrets
# This hook scans staged files for common secret patterns

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo "${YELLOW}üîí Scanning for secrets...${NC}"

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
  echo "${GREEN}‚úÖ No files staged for commit${NC}"
  exit 0
fi

# Common secret patterns to detect
SECRET_PATTERNS=(
  # NPM tokens (most specific first)
  "//.*registry.*:_authToken=[A-Za-z0-9_-]{20,}"
  # AWS keys
  "AKIA[0-9A-Z]{16}"
  # GitHub tokens
  "ghp_[A-Za-z0-9]{36}"
  "gho_[A-Za-z0-9]{36}"
  "ghu_[A-Za-z0-9]{36}"
  "ghs_[A-Za-z0-9]{36}"
  "ghr_[A-Za-z0-9]{36}"
  # Firebase
  "AAAA[A-Za-z0-9_-]{107}"
  # Google OAuth
  "[0-9]+-[0-9A-Za-z_]{32}\.[0-9A-Za-z_-]{149}"
  # Slack tokens
  "xox[baprs]-[0-9a-zA-Z-]{10,48}"
  # Stripe keys
  "sk_live_[0-9a-zA-Z]{24,}"
  "pk_live_[0-9a-zA-Z]{24,}"
  "rk_live_[0-9a-zA-Z]{24,}"
  # Private keys
  "-----BEGIN.*PRIVATE KEY-----"
  # API keys with explicit naming
  "api[_-]?key[=:]\s*['\"]?[A-Za-z0-9_-]{20,}['\"]?"
  "apikey[=:]\s*['\"]?[A-Za-z0-9_-]{20,}['\"]?"
  # Password patterns
  "password[=:]\s*['\"]?[A-Za-z0-9!@#$%^&*()_+-=]{8,}['\"]?"
  "pwd[=:]\s*['\"]?[A-Za-z0-9!@#$%^&*()_+-=]{8,}['\"]?"
  # Database URLs with passwords
  "(postgres|mysql|mongodb)://[^:]+:[^@]+@"
  # Generic tokens (40+ chars to reduce false positives, exclude common patterns)
  "[A-Za-z0-9_-]{40,}"
)

# Files that commonly contain secrets (but we allow if using env vars)
SUSPICIOUS_FILES=(
  "\.npmrc$"
  "\.env$"
  "\.env\."
  "secrets"
  "credentials"
  "\.pem$"
  "\.key$"
  "\.p12$"
  "\.pfx$"
  "id_rsa"
  "id_dsa"
  "\.secret"
)

# False positive patterns (allowed)
FALSE_POSITIVE_PATTERNS=(
  # UUIDs (standard format)
  "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"
  # Git commit SHAs (40 char hex)
  "[0-9a-f]{40}"
  # Short hex colors (# followed by 6 hex chars)
  "#[0-9a-f]{6}"
  # Base64 padding patterns (common in encoded data, not secrets)
  "[A-Za-z0-9+/=]{50,}"
  # Test IDs like 'user-123'
  "(test|mock|sample|fixture|example)[_-]?[0-9]+"
  # CSS custom properties (var(--...))
  "var\(--[^)]+\)"
  # Generated hash-like strings in tests
  "[a-z]+-[0-9]+"
)

FOUND_SECRETS=0
VIOLATIONS=""
BYPASS_AVAILABLE=false

# Check each staged file
for FILE in $STAGED_FILES; do
  # Skip binary files
  if git diff --cached --numstat "$FILE" 2>/dev/null | grep -q '^-'; then
    continue
  fi
  
  # Get the staged content
  STAGED_CONTENT=$(git show ":$FILE" 2>/dev/null)
  
  if [ -z "$STAGED_CONTENT" ]; then
    continue
  fi
  
  # Check for secret-safe comments (escape hatch with documentation)
  # Format: /* SECRET-SAFE: reason */ or // SECRET-SAFE: reason
  if echo "$STAGED_CONTENT" | grep -qiE "(SECRET-SAFE|HOOK-BYPASS|ALLOW-SECRET)[:].*"; then
    REASON=$(echo "$STAGED_CONTENT" | grep -iE "(SECRET-SAFE|HOOK-BYPASS|ALLOW-SECRET)[:]" | head -1 | sed 's/.*:\s*//' | sed 's/\*\/.*//' | sed 's/.*\/\/\s*//')
    echo "${BLUE}‚ÑπÔ∏è  File ${FILE} has SECRET-SAFE annotation: ${REASON}${NC}"
    continue  # Skip this file
  fi
  
  # Check for suspicious file names
  for SUSPICIOUS in "${SUSPICIOUS_FILES[@]}"; do
    if echo "$FILE" | grep -qiE "$SUSPICIOUS"; then
      # Allow if it's using environment variables
      if echo "$STAGED_CONTENT" | grep -qiE '\$\{[A-Z_][A-Z0-9_]*\}|\$[A-Z_][A-Z0-9_]*|process\.env\.[A-Z_][A-Z0-9_]*'; then
        continue
      fi
      
      VIOLATIONS="${VIOLATIONS}\n${RED}‚ö†Ô∏è  Suspicious file: ${FILE}${NC}"
      VIOLATIONS="${VIOLATIONS}\n   This file type commonly contains secrets. Ensure you're using environment variables."
      VIOLATIONS="${VIOLATIONS}\n   ${YELLOW}Or add: /* SECRET-SAFE: explanation */${NC}"
      FOUND_SECRETS=$((FOUND_SECRETS + 1))
    fi
  done
  
  # Check for secret patterns
  for PATTERN in "${SECRET_PATTERNS[@]}"; do
    MATCHES=$(echo "$STAGED_CONTENT" | grep -oiE "$PATTERN" | head -10)
    
    if [ -n "$MATCHES" ]; then
      EXCLUDED=false
      
      # Check if it's an environment variable
      if echo "$STAGED_CONTENT" | grep -qiE '\$\{[A-Z_][A-Z0-9_]*\}|\$[A-Z_][A-Z0-9_]*|process\.env\.[A-Z_][A-Z0-9_]*'; then
        EXCLUDED=true
      fi
      
      # Exclude comments (but still warn for secrets in comments)
      LINE_CONTEXT=$(echo "$STAGED_CONTENT" | grep -oiE "$PATTERN" -B 2 -A 2 | grep -E "^[[:space:]]*[#/]" | head -1)
      if [ -n "$LINE_CONTEXT" ]; then
        # Allow if it's a documentation example or clearly marked
        if echo "$LINE_CONTEXT" | grep -qiE "(example|sample|documentation|test|mock|placeholder)"; then
          EXCLUDED=true
        fi
      fi
      
      # Exclude test fixtures, mocks, examples
      if echo "$FILE" | grep -qiE "(test|spec|fixture|mock|example|sample|playground|docs/.*example)"; then
        EXCLUDED=true
      fi
      
      # Check against false positive patterns
      for FP_PATTERN in "${FALSE_POSITIVE_PATTERNS[@]}"; do
        if echo "$MATCHES" | grep -qiE "$FP_PATTERN"; then
          EXCLUDED=true
          break
        fi
      done
      
      # Exclude if it's in a string literal that's clearly a variable name or example
      if echo "$STAGED_CONTENT" | grep -qiE "(['\"].*$PATTERN.*['\"])" && \
         echo "$STAGED_CONTENT" | grep -qiE "(example|sample|placeholder|test|mock|fixture)"; then
        EXCLUDED=true
      fi
      
      # Exclude short numeric-only strings (likely not secrets)
      if echo "$MATCHES" | grep -qE "^[0-9]{32,}$"; then
        EXCLUDED=true
      fi
      
      if [ "$EXCLUDED" = false ]; then
        VIOLATIONS="${VIOLATIONS}\n${RED}üö® SECRET DETECTED in ${FILE}:${NC}"
        echo "$MATCHES" | while read -r match; do
          # Mask the secret (show first 8 chars, mask the rest)
          MASKED=$(echo "$match" | sed 's/\(.\{8\}\).*/\1****************/')
          VIOLATIONS="${VIOLATIONS}\n   ${RED}Found: ${MASKED}${NC}"
        done
        VIOLATIONS="${VIOLATIONS}\n   ${YELLOW}If this is a false positive, add: /* SECRET-SAFE: explanation */${NC}"
        FOUND_SECRETS=$((FOUND_SECRETS + 1))
      fi
    fi
  done
done

# Report results
if [ $FOUND_SECRETS -gt 0 ]; then
  echo ""
  echo "${RED}‚ùå SECURITY VIOLATION DETECTED!${NC}"
  echo "${RED}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo -e "$VIOLATIONS"
  echo ""
  echo "${YELLOW}‚ö†Ô∏è  COMMIT BLOCKED${NC}"
  echo ""
  echo "${YELLOW}To fix:${NC}"
  echo "1. Remove the secrets from your files"
  echo "2. Use environment variables instead (e.g., \${VARIABLE_NAME})"
  echo "3. Ensure .env files are in .gitignore"
  echo "4. Ensure .npmrc uses environment variables, not hardcoded tokens"
  echo ""
  echo "${BLUE}For legitimate false positives:${NC}"
  echo "  Add a comment above the line:"
  echo "    ${GREEN}/* SECRET-SAFE: This is test data / This is a UUID / etc */${NC}"
  echo "  Or for entire files, add at the top:"
  echo "    ${GREEN}/* SECRET-SAFE: File contains mock tokens for testing */${NC}"
  echo ""
  echo "${YELLOW}Emergency bypass (with provenance tracking):${NC}"
  echo "  ${RED}git commit --no-verify${NC}"
  echo "  ${YELLOW}This will be logged for security audit. Use only if absolutely necessary.${NC}"
  echo ""
  
  # Log bypass attempt if using --no-verify (we can detect this)
  if [ "$SKIP_HOOK" = "1" ] || echo "$GIT_COMMIT_MESSAGE" | grep -qi "no-verify"; then
    BYPASS_AVAILABLE=true
  fi
  
  exit 1
fi

echo "${GREEN}‚úÖ No secrets detected${NC}"
exit 0
